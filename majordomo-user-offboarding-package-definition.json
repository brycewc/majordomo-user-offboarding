{
  "packageId": "d5c46aaa-963f-4e01-a84a-f89ccea6465a",
  "version": "1.0.47",
  "code": "/* eslint require-atomic-updates: 0 */\nconst codeengine = require('codeengine');\n\nconst logDatasetId = '83dec9f2-206b-445a-90ea-b6a368b3157d'; // Format: userId,newOwnerId,type,id,date,status,notes\nconst domostatsScheduledReportsDatasetId =\n\t'b7306441-b8a7-481c-baaf-4fffadb0ff61'; // https://www.domo.com/appstore/connector/domostats/datasets\n\nclass Helpers {\n\t/**\n\t * Helper function to handle API requests and errors\n\t * @param {text} method - The HTTP method\n\t * @param {text} url - The endpoint URL\n\t * @param {Object} [body=null] - The request body\n\t * @param {Object} [headers=null] - The request headers\n\t * @param {text} [content='application/json'] - Request body content type\n\t * @returns {Object} The response data\n\t * @throws {Error} If the request fails\n\t */\n\tstatic async handleRequest(\n\t\tmethod,\n\t\turl,\n\t\tbody = null,\n\t\theaders = null,\n\t\tcontentType = 'application/json'\n\t) {\n\t\ttry {\n\t\t\treturn await codeengine.sendRequest(\n\t\t\t\tmethod,\n\t\t\t\turl,\n\t\t\t\tbody,\n\t\t\t\theaders,\n\t\t\t\tcontentType\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`Error with ${method} request to ${url}\\nError:\\n${JSON.stringify(\n\t\t\t\t\terror\n\t\t\t\t)}\\nPayload:\\n${JSON.stringify(body, null, 2)}`\n\t\t\t);\n\t\t\t// throw error;\n\t\t}\n\t}\n}\n\nconst { handleRequest } = Helpers;\n\nasync function getUserName(userId) {\n\tconst url = `/api/content/v3/users/${userId}`;\n\tconst user = await handleRequest('GET', url);\n\treturn user.displayName || null;\n}\n\n/**\n * Retrieve all active sessions and delete those belonging to the specified user.\n *\n * @param {string} userId - The Domo user ID for which to delete active sessions.\n * @returns {Promise<void>} Resolves when all user's sessions are deleted or rejects on error.\n */\nasync function deleteUserSessions(userId) {\n\tconst url = '/api/sessions/v1/admin?limit=99999999';\n\t// Fetch all sessions (potentially large number depending on 'limit')\n\tconst response = await handleRequest('GET', url);\n\n\t// Find sessions assigned to the specified user\n\tconst sessionsToDelete = response.filter((s) => s.userId === userId);\n\tif (sessionsToDelete.length > 0) {\n\t\t// Delete all sessions concurrently and wait for completion\n\t\tawait Promise.all(sessionsToDelete.map((s) => deleteSession(s.id)));\n\t}\n}\n\n/**\n * Retrieve all active sessions and delete those belonging to the specified users.\n *\n * @param {number[]} userIds - Array of Domo user IDs for which to delete active sessions.\n * @returns {Promise<void>} Resolves when all users' sessions are deleted or rejects on error.\n */\nasync function deleteUsersSessions(userIds) {\n\tconst url = '/api/sessions/v1/admin?limit=99999999';\n\t// Fetch all sessions (potentially large number depending on 'limit')\n\tconst response = await handleRequest('GET', url);\n\n\t// Find sessions assigned to any of the specified users\n\tconst sessionsToDelete = response.filter((s) => userIds.includes(s.userId));\n\tif (sessionsToDelete.length > 0) {\n\t\t// Delete all sessions concurrently and wait for completion\n\t\tawait Promise.all(sessionsToDelete.map((s) => deleteSession(s.id)));\n\t}\n}\n\n/**\n * Delete a session by its session ID.\n *\n * @param {string} sessionId - The ID of the session to delete.\n * @returns {Promise<void>} Resolves after session deletion, or logs error if deletion fails.\n */\nasync function deleteSession(sessionId) {\n\tconst url = `api/sessions/v1/admin/${sessionId}`;\n\n\tawait handleRequest('DELETE', url);\n}\n\n/**\n * Delete a user by its ID.\n *\n * @param {string} userId - The ID of the user to delete.\n * @returns {Promise<void>} Resolves after session deletion, or logs error if deletion fails.\n */\nasync function deleteUser(userId) {\n\tconst url = `/api/identity/v1/users/${userId}`;\n\n\tawait handleRequest('DELETE', url);\n}\n\nasync function appendToDataset(csvValues, datasetId = logDatasetId) {\n\tconst uploadUrl = `api/data/v3/datasources/${datasetId}/uploads`;\n\tconst uploadBody = {\n\t\taction: 'APPEND',\n\t\tmessage: 'Uploading',\n\t\tappendId: 'latest'\n\t};\n\t// Start upload session\n\tconst { uploadId } = await handleRequest('POST', uploadUrl, uploadBody);\n\n\t// Upload data part\n\tconst partsUrl = uploadUrl + `/${uploadId}/parts/1`;\n\t//const partsUrl = UPLOADS_PARTS_URL.replace(':id', dataset).replace(':uploadId', uploadId);\n\tawait handleRequest('PUT', partsUrl, csvValues, null, 'text/csv');\n\n\t// Commit upload\n\tconst commitUrl = uploadUrl + `/${uploadId}/commit`;\n\t//const commitUrl = UPLOADS_COMMIT_URL.replace(':id', dataset).replace(':uploadId', uploadId);\n\tconst commitBody = {\n\t\tindex: true,\n\t\tappendId: 'latest',\n\t\tmessage: 'Append successful'\n\t};\n\n\treturn await handleRequest('PUT', commitUrl, commitBody);\n}\n\nasync function logTransfers(\n\tuserId,\n\tnewOwnerId,\n\ttype,\n\tids,\n\tstatus = 'TRANSFERRED',\n\tnotes = null\n) {\n\tconst BATCH_SIZE = 50;\n\tlet batch = [];\n\tconst date = new Date().toISOString().slice(0, -5); // Format: YYYY-MM-DDTHH:mm:ss\n\n\tfor (const id of ids) {\n\t\tbatch.push(\n\t\t\t`${userId},${newOwnerId},${type},${id},${date},${status},${notes}`\n\t\t);\n\n\t\tif (batch.length >= BATCH_SIZE) {\n\t\t\ttry {\n\t\t\t\tawait appendToDataset(batch.join('\\n') + '\\n', logDatasetId);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Logging failed:', error);\n\t\t\t}\n\t\t\tbatch = [];\n\t\t}\n\t}\n\n\tif (batch.length > 0) {\n\t\ttry {\n\t\t\tawait appendToDataset(batch.join('\\n') + '\\n', logDatasetId);\n\t\t} catch (error) {\n\t\t\tconsole.error('Logging failed:', error);\n\t\t}\n\t}\n}\n\n//---------------------------TRANSFER-----------------------//\n\nasync function transferContent(userId, newOwnerId, objectsToTransfer = []) {\n\tlet currentPeriodId = await getCurrentPeriod();\n\n\t// Handle null or undefined by converting to empty array\n\tif (!objectsToTransfer) {\n\t\tobjectsToTransfer = [];\n\t}\n\n\t// Parse objects by type if specific objects are provided\n\tconst objectsByType = {};\n\tif (objectsToTransfer.length > 0) {\n\t\tfor (const obj of objectsToTransfer) {\n\t\t\tif (!objectsByType[obj.type]) {\n\t\t\t\tobjectsByType[obj.type] = [];\n\t\t\t}\n\t\t\tobjectsByType[obj.type].push(obj.id);\n\t\t}\n\t}\n\n\tawait Promise.all([\n\t\ttransferDatasets(userId, newOwnerId, objectsByType['DATA_SOURCE'] || []),\n\n\t\ttransferDataflows(userId, newOwnerId, objectsByType['DATAFLOW_TYPE'] || []),\n\n\t\ttransferCards(userId, newOwnerId, objectsByType['CARD'] || []),\n\n\t\ttransferAlerts(userId, newOwnerId, objectsByType['ALERT'] || []),\n\n\t\ttransferWorkflows(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tobjectsByType['WORKFLOW_MODEL'] || []\n\t\t),\n\n\t\ttransferTaskCenterQueues(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tobjectsByType['HOPPER_QUEUE'] || []\n\t\t),\n\n\t\ttransferTaskCenterTasks(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tobjectsByType['HOPPER_TASK'] || []\n\t\t),\n\n\t\ttransferAppStudioApps(userId, newOwnerId, objectsByType['DATA_APP'] || []),\n\n\t\ttransferPages(userId, newOwnerId, objectsByType['PAGE'] || []),\n\n\t\ttransferScheduledReports(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tobjectsByType['REPORT_SCHEDULE'] || []\n\t\t),\n\n\t\ttransferGoals(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tcurrentPeriodId,\n\t\t\tobjectsByType['GOAL'] || []\n\t\t),\n\n\t\ttransferGroups(userId, newOwnerId, objectsByType['GROUP'] || []),\n\n\t\ttransferAppDbCollections(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tobjectsByType['COLLECTION'] || []\n\t\t),\n\n\t\ttransferFunctions(userId, newOwnerId, [\n\t\t\t...(objectsByType['BEAST_MODE_FORMULA'] || []),\n\t\t\t...(objectsByType['VARIABLE'] || [])\n\t\t]),\n\n\t\ttransferAccounts(userId, newOwnerId, objectsByType['ACCOUNT'] || []),\n\n\t\ttransferJupyterWorkspaces(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tobjectsByType['DATA_SCIENCE_NOTEBOOK'] || []\n\t\t),\n\n\t\ttransferCodeEnginePackages(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tobjectsByType['CODEENGINE_PACKAGE'] || []\n\t\t),\n\n\t\ttransferFilesets(userId, newOwnerId, objectsByType['FILESET'] || []),\n\n\t\tgetPublications(userId, newOwnerId, objectsByType['PUBLICATION'] || []),\n\n\t\ttransferSubscriptions(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\tobjectsByType['SUBSCRIPTION'] || []\n\t\t),\n\n\t\ttransferRepositories(userId, newOwnerId, objectsByType['REPOSITORY'] || []),\n\n\t\t...(objectsToTransfer.length === 0\n\t\t\t? [transferApprovals(userId, newOwnerId)]\n\t\t\t: []),\n\n\t\t...(objectsToTransfer.length === 0\n\t\t\t? [transferApprovalTemplates(userId, newOwnerId)]\n\t\t\t: []),\n\n\t\ttransferCustomApps(userId, newOwnerId, [\n\t\t\t...(objectsByType['APP'] || []),\n\t\t\t...(objectsByType['RYUU_APP'] || [])\n\t\t]),\n\n\t\ttransferAiModels(userId, newOwnerId, objectsByType['AI_MODEL'] || []),\n\n\t\ttransferAiProjects(userId, newOwnerId, objectsByType['AI_PROJECT'] || []),\n\n\t\ttransferProjectsAndTasks(userId, newOwnerId, [\n\t\t\t...(objectsByType['PROJECT_TASK'] || []),\n\t\t\t...(objectsByType['PROJECT'] || [])\n\t\t]),\n\n\t\ttransferMetrics(userId, newOwnerId, objectsByType['METRIC'] || [])\n\t]);\n}\n\n//-------------------------DataSets--------------------------//\n\nasync function transferDatasets(userId, newOwnerId, filteredIds = []) {\n\tconst userName = await getUserName(userId);\n\n\tlet allIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tallIds = filteredIds;\n\t} else {\n\t\t// Use existing get logic\n\t\tconst endpoint = '/api/data/ui/v3/datasources/ownedBy';\n\t\tconst data = [\n\t\t\t{\n\t\t\t\tid: userId.toString(),\n\t\t\t\ttype: 'USER'\n\t\t\t}\n\t\t];\n\n\t\tconst response = await handleRequest('POST', endpoint, data);\n\t\tif (response && response.length > 0) {\n\t\t\tif (response[0].dataSourceIds && response[0].dataSourceIds.length > 0) {\n\t\t\t\tallIds = response[0].dataSourceIds;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allIds.length > 0) {\n\t\t// Process datasets in batches\n\t\tconst batchSize = 50;\n\t\tfor (let i = 0; i < allIds.length; i += batchSize) {\n\t\t\tconst chunk = allIds.slice(i, i + batchSize);\n\t\t\t// Update owner\n\t\t\tconst body = {\n\t\t\t\ttype: 'DATA_SOURCE',\n\t\t\t\tids: chunk,\n\t\t\t\tuserId: newOwnerId\n\t\t\t};\n\t\t\tawait handleRequest('POST', '/api/data/v1/ui/bulk/reassign', body);\n\t\t\t// Add new tags\n\t\t\tconst tagsBody = {\n\t\t\t\tbulkItems: {\n\t\t\t\t\tids: chunk,\n\t\t\t\t\ttype: 'DATA_SOURCE'\n\t\t\t\t},\n\t\t\t\ttags: [`From ${userName}`]\n\t\t\t};\n\t\t\tawait handleRequest('POST', '/api/data/v1/ui/bulk/tag', tagsBody);\n\t\t}\n\n\t\tawait logTransfers(userId, newOwnerId, 'DATA_SOURCE', allIds);\n\t}\n}\n\n//----------------------------DataFlows-----------------------//\n\nasync function transferDataflows(userId, newOwnerId, filteredIds = []) {\n\tconst userName = await getUserName(userId);\n\n\tlet allIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tallIds = filteredIds;\n\t} else {\n\t\t// Use existing get logic\n\t\tconst count = 100;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tentities: ['DATAFLOW'],\n\t\t\t\tfilters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: 'owned_by_id',\n\t\t\t\t\t\tfilterType: 'term',\n\t\t\t\t\t\tvalue: userId\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tquery: '*',\n\t\t\t\tcount: count,\n\t\t\t\toffset: offset\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/search/v1/query',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response.searchObjects && response.searchObjects.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst dataflows = response.searchObjects;\n\t\t\t\tconst ids = dataflows.map((dataflow) => dataflow.databaseId);\n\t\t\t\tallIds.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += count;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.searchObjects.length < count) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allIds.length > 0) {\n\t\tconst url = '/api/dataprocessing/v1/dataflows/bulk/patch';\n\n\t\t// Note: We can't easily get existing tags when using filtered IDs, so we'll skip tag cleanup for filtered transfers\n\t\tif (filteredIds.length === 0) {\n\t\t\t// Only do tag cleanup when doing full transfer (not filtered)\n\t\t\tconst tags = []; // This would need to be retrieved per dataflow, which is complex\n\t\t\tif (tags.length > 0) {\n\t\t\t\tconst oldTags = tags.filter((tag) => tag.startsWith('From')) || [];\n\n\t\t\t\t// Remove tags\n\t\t\t\tif (oldTags.length > 0) {\n\t\t\t\t\tconst removetagsBody = {\n\t\t\t\t\t\tdataFlowIds: allIds,\n\t\t\t\t\t\ttagNames: oldTags\n\t\t\t\t\t};\n\t\t\t\t\tawait handleRequest(\n\t\t\t\t\t\t'PUT',\n\t\t\t\t\t\t'/api/dataprocessing/v1/dataflows/bulk/tag/delete',\n\t\t\t\t\t\tremovetagsBody\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Log transfers\n\t\tawait logTransfers(userId, newOwnerId, 'DATAFLOW_TYPE', allIds);\n\n\t\t// Update owner\n\t\tconst body = {\n\t\t\tdataFlowIds: allIds,\n\t\t\tresponsibleUserId: newOwnerId\n\t\t};\n\t\tawait handleRequest('PUT', url, body);\n\n\t\t// Add new tags in batches of 50\n\t\tfor (let i = 0; i < allIds.length; i += 50) {\n\t\t\tconst chunk = allIds.slice(i, i + 50);\n\t\t\tconst addTagsBody = {\n\t\t\t\tdataFlowIds: chunk,\n\t\t\t\ttagNames: [`From ${userName}`]\n\t\t\t};\n\t\t\tawait handleRequest(\n\t\t\t\t'PUT',\n\t\t\t\t'/api/dataprocessing/v1/dataflows/bulk/tag',\n\t\t\t\taddTagsBody\n\t\t\t);\n\t\t}\n\t}\n}\n\n//----------------------Cards-------------------------//\n\nasync function transferCards(userId, newOwnerId, filteredIds = []) {\n\tconst url = '/api/search/v1/query';\n\n\tlet allIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tallIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet offset = 0;\n\t\tconst count = 50;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tcount: count,\n\t\t\t\toffset: offset,\n\t\t\t\tcombineResults: false,\n\t\t\t\tquery: '*',\n\t\t\t\tfilters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'OWNED_BY_ID',\n\t\t\t\t\t\tfield: 'owned_by_id',\n\t\t\t\t\t\tfacetType: 'user',\n\t\t\t\t\t\tvalue: `${userId}:USER`,\n\t\t\t\t\t\tfilterType: 'term'\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tentityList: [['card']]\n\t\t\t};\n\n\t\t\tconst response = await handleRequest('POST', url, data);\n\n\t\t\tif (response.searchObjects && response.searchObjects.length > 0) {\n\t\t\t\tconst ids = response.searchObjects.map((card) => card.databaseId);\n\t\t\t\tallIds.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += count;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.searchObjects.length < count) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allIds.length > 0) {\n\t\tlet body = {\n\t\t\tcardIds: allIds,\n\t\t\tcardOwners: [\n\t\t\t\t{\n\t\t\t\t\tid: newOwnerId,\n\t\t\t\t\ttype: 'USER'\n\t\t\t\t}\n\t\t\t],\n\t\t\tnote: '',\n\t\t\tsendEmail: false\n\t\t};\n\n\t\tawait handleRequest('POST', '/api/content/v1/cards/owners/add', body);\n\n\t\tbody.cardOwners = [\n\t\t\t{\n\t\t\t\tid: userId,\n\t\t\t\ttype: 'USER'\n\t\t\t}\n\t\t];\n\n\t\t// await handleRequest('POST', '/api/content/v1/cards/owners/remove', body); // Removing because their ownership will be removed when they are deleted\n\n\t\tawait logTransfers(userId, newOwnerId, 'CARD', allIds);\n\t}\n}\n\n// -----------------Alerts--------------------------//\n/**\n * Get alerts a user is subscribed to\n *\n * @param {string} userId - The ID of the user to get alerts for.\n * @returns {List<int>} List of alert IDs the user is subscribed to.\n */\nasync function transferAlerts(userId, newOwnerId, filteredIds = []) {\n\tlet alerts = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\talerts = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet moreData = true;\n\t\tlet offset = 0;\n\t\tconst limit = 50;\n\n\t\twhile (moreData) {\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'GET',\n\t\t\t\t`/api/social/v4/alerts?ownerId=${userId}&limit=${limit}&offset=${offset}`\n\t\t\t);\n\n\t\t\tif (response.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.map((alert) => alert.id);\n\t\t\t\talerts.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (alerts.length > 0) {\n\t\tfor (let i = 0; i < alerts.length; i++) {\n\t\t\tconst body = {\n\t\t\t\tid: alerts[i],\n\t\t\t\towner: newOwnerId\n\t\t\t};\n\t\t\tconst url = `/api/social/v4/alerts/${alerts[i]}`;\n\t\t\tawait handleRequest('PATCH', url, body);\n\t\t}\n\n\t\tawait logTransfers(userId, newOwnerId, 'ALERT', alerts);\n\t}\n}\n\n//---------------------------Workflows--------------------------------//\n/**\n * Get Workflows owned by given user ID and transfer ownership by updating the full workflow object\n *\n * @param {string} userId - The ID of the owner to search for.\n * @param {string} newOwnerId - The ID of the new owner.\n */\nasync function transferWorkflows(userId, newOwnerId, filteredIds = []) {\n\tlet workflowIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tworkflowIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst count = 100;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tquery: '*',\n\t\t\t\tentityList: [['workflow_model']],\n\t\t\t\tcount: count,\n\t\t\t\toffset: offset,\n\t\t\t\tfilters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfacetType: 'user',\n\t\t\t\t\t\tfilterType: 'term',\n\t\t\t\t\t\tfield: 'owned_by_id',\n\t\t\t\t\t\tvalue: `${userId}:USER`\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/search/v1/query',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response.searchObjects && response.searchObjects.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.searchObjects.map((workflow) => workflow.uuid);\n\t\t\t\tworkflowIds.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += count;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.searchObjects.length < count) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (workflowIds.length > 0) {\n\t\t// Process each workflow individually by fetching the full object and updating it\n\t\tfor (let i = 0; i < workflowIds.length; i++) {\n\t\t\tconst workflowId = workflowIds[i];\n\n\t\t\t// Get the full workflow object\n\t\t\tconst workflow = await handleRequest(\n\t\t\t\t'GET',\n\t\t\t\t`/api/workflow/v1/models/${workflowId}`\n\t\t\t);\n\n\t\t\t// Update the owner property\n\t\t\tworkflow.owner = newOwnerId.toString();\n\n\t\t\t// Save the workflow with the updated owner\n\t\t\tawait handleRequest(\n\t\t\t\t'PUT',\n\t\t\t\t`/api/workflow/v1/models/${workflowId}`,\n\t\t\t\tworkflow\n\t\t\t);\n\t\t}\n\n\t\tawait logTransfers(userId, newOwnerId, 'WORKFLOW_MODEL', workflowIds);\n\t}\n}\n\n//--------------------------Task Center Queues--------------------------//\n\nasync function transferTaskCenterQueues(userId, newOwnerId, filteredIds = []) {\n\tlet queues = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tqueues = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst count = 100;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tquery: '*',\n\t\t\t\tentityList: [['queue']],\n\t\t\t\tcount: count,\n\t\t\t\toffset: offset,\n\t\t\t\tfilters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfacetType: 'user',\n\t\t\t\t\t\tfilterType: 'term',\n\t\t\t\t\t\tfield: 'owned_by_id',\n\t\t\t\t\t\tvalue: `${userId}:USER`\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/search/v1/query',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response.searchObjects && response.searchObjects.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.searchObjects.map((queue) => queue.uuid);\n\t\t\t\tqueues.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += count;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.searchObjects.length < count) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (queues.length > 0) {\n\t\tfor (let i = 0; i < queues.length; i++) {\n\t\t\tawait handleRequest(\n\t\t\t\t'PUT',\n\t\t\t\t`/api/queues/v1/${queues[i]}/owner/${newOwnerId}`,\n\t\t\t\tnull,\n\t\t\t\t{ 'Content-Type': 'application/json' }\n\t\t\t);\n\t\t}\n\n\t\tawait logTransfers(userId, newOwnerId, 'HOPPER_QUEUE', queues);\n\t}\n}\n\n//--------------------------Task Center Tasks--------------------------//\n\nasync function transferTaskCenterTasks(userId, newOwnerId, filteredIds = []) {\n\tlet tasks = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list - for tasks we need to fetch queue info\n\t\tconst taskDetails = [];\n\t\tfor (const taskId of filteredIds) {\n\t\t\t// We'd need to find the queue for each task, but this is complex\n\t\t\t// For now, just store the ID and handle the transfer\n\t\t\ttaskDetails.push({ id: taskId, queueId: null });\n\t\t}\n\t\ttasks = taskDetails;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet offset = 0;\n\t\tconst limit = 100;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t`/api/queues/v1/tasks/list?limit=${limit}&offset=${offset}`,\n\t\t\t\t{ assignedTo: [userId], status: ['OPEN'] }\n\t\t\t);\n\n\t\t\tif (response && response.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.map((task) => ({\n\t\t\t\t\tid: task.id,\n\t\t\t\t\tqueueId: task.queueId\n\t\t\t\t}));\n\t\t\t\ttasks.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tasks.length > 0) {\n\t\tconst taskIdList = [];\n\n\t\tfor (let i = 0; i < tasks.length; i++) {\n\t\t\tif (tasks[i].queueId) {\n\t\t\t\tconst url = `/api/queues/v1/${tasks[i].queueId}/tasks/${tasks[i].id}/assign`;\n\t\t\t\tconst body = {\n\t\t\t\t\tuserId: newOwnerId,\n\t\t\t\t\ttype: 'USER',\n\t\t\t\t\ttaskIds: [tasks[i].id]\n\t\t\t\t};\n\t\t\t\tawait handleRequest('PUT', url, body);\n\t\t\t}\n\t\t\ttaskIdList.push(tasks[i].id);\n\t\t}\n\n\t\tawait logTransfers(userId, newOwnerId, 'HOPPER_TASK', taskIdList);\n\t}\n}\n\n//------------------------------------App Studio--------------------------//\n\nasync function transferAppStudioApps(userId, newOwnerId, filteredIds = []) {\n\tlet allApps = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tallApps = filteredIds.map((id) => id.toString());\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst limit = 30;\n\t\tlet skip = 0;\n\t\tlet moreData = true;\n\t\tconst data = {};\n\n\t\twhile (moreData) {\n\t\t\tconst url = `/api/content/v1/dataapps/adminsummary?limit=${limit}&skip=${skip}`;\n\t\t\tconst response = await handleRequest('POST', url, data);\n\n\t\t\tif (\n\t\t\t\tresponse.dataAppAdminSummaries &&\n\t\t\t\tresponse.dataAppAdminSummaries.length > 0\n\t\t\t) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst apps = response.dataAppAdminSummaries\n\t\t\t\t\t.filter((item) => item.owners.some((owner) => owner.id == userId))\n\t\t\t\t\t.map((item) => item.dataAppId.toString());\n\t\t\t\tallApps.push(...apps);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\tskip += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.dataAppAdminSummaries.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allApps.length > 0) {\n\t\tconst addBody = {\n\t\t\tnote: '',\n\t\t\tentityIds: allApps,\n\t\t\towners: [{ type: 'USER', id: parseInt(newOwnerId) }],\n\t\t\tsendEmail: false\n\t\t};\n\n\t\tawait handleRequest('PUT', '/api/content/v1/dataapps/bulk/owners', addBody);\n\n\t\tconst removeBody = {\n\t\t\tentityIds: allApps,\n\t\t\towners: [{ type: 'USER', id: userId }]\n\t\t};\n\n\t\tawait handleRequest(\n\t\t\t'POST',\n\t\t\t'/api/content/v1/dataapps/bulk/owners/remove',\n\t\t\tremoveBody\n\t\t);\n\n\t\tawait logTransfers(userId, newOwnerId, 'DATA_APP', allApps);\n\t}\n}\n\n//-----------------------------------Pages------------------------------//\n\nasync function transferPages(userId, newOwnerId, filteredIds = []) {\n\tlet allPages = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tallPages = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet skip = 0;\n\t\tconst limit = 50;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst url = `/api/content/v1/pages/adminsummary?limit=${limit}&skip=${skip}`;\n\t\t\tconst data = {\n\t\t\t\taddPageWithNoOwner: false,\n\t\t\t\tincludePageOwnerClause: 1,\n\t\t\t\townerIds: [userId],\n\t\t\t\tgroupOwnerIds: [],\n\t\t\t\torderBy: 'pageTitle',\n\t\t\t\tascending: true\n\t\t\t};\n\n\t\t\tconst response = await handleRequest('POST', url, data);\n\n\t\t\tif (\n\t\t\t\tresponse.pageAdminSummaries &&\n\t\t\t\tresponse.pageAdminSummaries.length > 0\n\t\t\t) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst pages = response.pageAdminSummaries.map((page) => page.pageId);\n\t\t\t\tallPages.push(...pages);\n\n\t\t\t\t// Increment skip to get next page\n\t\t\t\tskip += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.pageAdminSummaries.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allPages.length > 0) {\n\t\tconst body = {\n\t\t\towners: [{ id: newOwnerId, type: 'USER' }],\n\t\t\tpageIds: allPages\n\t\t};\n\n\t\tawait handleRequest('PUT', '/api/content/v1/pages/bulk/owners', body);\n\n\t\tconst removeBody = {\n\t\t\towners: [\n\t\t\t\t{\n\t\t\t\t\tid: parseInt(userId),\n\t\t\t\t\ttype: 'USER'\n\t\t\t\t}\n\t\t\t],\n\t\t\tpageIds: allPages\n\t\t};\n\n\t\tawait handleRequest(\n\t\t\t'POST',\n\t\t\t'/api/content/v1/pages/bulk/owners/remove',\n\t\t\tremoveBody\n\t\t);\n\t\tawait logTransfers(userId, newOwnerId, 'PAGE', allPages);\n\t}\n}\n\n//---------------------------------Scheduled Reports--------------------------------//\n\nasync function transferScheduledReports(userId, newOwnerId, filteredIds = []) {\n\tlet reportIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\treportIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst url = `api/query/v1/execute/${domostatsScheduledReportsDatasetId}`;\n\t\tconst body = {\n\t\t\tquerySource: 'data_table',\n\t\t\tuseCache: true,\n\t\t\tquery: {\n\t\t\t\tcolumns: [\n\t\t\t\t\t{\n\t\t\t\t\t\texprType: 'COLUMN',\n\t\t\t\t\t\tcolumn: 'Report Id'\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tlimit: {\n\t\t\t\t\tlimit: 10000,\n\t\t\t\t\toffset: 0\n\t\t\t\t},\n\t\t\t\torderByColumns: [],\n\t\t\t\tgroupByColumns: [],\n\t\t\t\twhere: {\n\t\t\t\t\tnot: false,\n\t\t\t\t\texprType: 'IN',\n\t\t\t\t\tleftExpr: {\n\t\t\t\t\t\texprType: 'COLUMN',\n\t\t\t\t\t\tcolumn: 'Owner Id'\n\t\t\t\t\t},\n\t\t\t\t\tselectSet: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\texprType: 'STRING_VALUE',\n\t\t\t\t\t\t\tvalue: userId\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\thaving: null\n\t\t\t},\n\t\t\tcontext: {\n\t\t\t\tcalendar: 'StandardCalendar',\n\t\t\t\tfeatures: {\n\t\t\t\t\tPerformTimeZoneConversion: true,\n\t\t\t\t\tAllowNullValues: true,\n\t\t\t\t\tTreatNumbersAsStrings: true\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Used for Views Explorer, not the regular Data table\n\t\t\tviewTemplate: null,\n\t\t\ttableAliases: null\n\t\t};\n\n\t\tconst response = await handleRequest('POST', url, body);\n\t\tconst reports = response.rows;\n\t\treportIds = reports.map((r) => r[0]);\n\t}\n\n\tif (reportIds.length > 0) {\n\t\tfor (let i = 0; i < reportIds.length; i++) {\n\t\t\tconst endpoint = `/api/content/v1/reportschedules/${reportIds[i]}`;\n\n\t\t\tlet report = await handleRequest('GET', endpoint);\n\t\t\tlet reportBody = {\n\t\t\t\tid: report.id,\n\t\t\t\townerId: newOwnerId,\n\t\t\t\tschedule: report.schedule,\n\t\t\t\tsubject: report.subject,\n\t\t\t\tviewId: report.viewId\n\t\t\t};\n\t\t\treport.ownerId = newOwnerId;\n\t\t\tawait handleRequest('PUT', endpoint, reportBody);\n\t\t}\n\t\tawait logTransfers(userId, newOwnerId, 'REPORT_SCHEDULE', reportIds);\n\t}\n}\n\n//---------------------------------------------Goals------------------------------------------------//\n\nasync function getCurrentPeriod() {\n\tconst response = await handleRequest(\n\t\t'GET',\n\t\t'/api/social/v1/objectives/periods?all=true'\n\t);\n\tconst currentPeriod = response.find((period) => period.current);\n\treturn currentPeriod.id;\n}\n\nasync function transferGoals(userId, newOwnerId, periodId) {\n\tconst url = `api/social/v2/objectives/profile?filterKeyResults=false&includeSampleGoal=false&periodId=${periodId}&ownerId=${userId}`;\n\n\tconst goals = await handleRequest('GET', url);\n\tif (goals && goals.length > 0) {\n\t\tfor (let i = 0; i < goals.length; i++) {\n\t\t\tconst goalUrl = `/api/social/v1/objectives/${goals[i].id}`;\n\n\t\t\tgoals[i].ownerId = newOwnerId;\n\t\t\tgoals[i].owners = [\n\t\t\t\t{\n\t\t\t\t\townerId: newOwnerId,\n\t\t\t\t\townerType: 'USER',\n\t\t\t\t\tprimary: false\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tconst body = goals[i];\n\n\t\t\tawait handleRequest('PUT', goalUrl, body);\n\t\t}\n\t\tawait logTransfers(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\t'GOAL',\n\t\t\tgoals.map((goal) => goal.id)\n\t\t);\n\t}\n}\n\n//-----------------------------------------Groups----------------------------------------//\n\nasync function transferGroups(userId, newOwnerId, filteredIds = []) {\n\tlet allGroupIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tallGroupIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst limit = 100;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst url = `/api/content/v2/groups/grouplist?owner=${userId}&limit=${limit}&offset=${offset}`;\n\t\t\tconst response = await handleRequest('GET', url);\n\n\t\t\tif (response && response.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst groupIds = response\n\t\t\t\t\t.filter((group) => group.owners.some((owner) => owner.id === userId))\n\t\t\t\t\t.map((group) => group.id);\n\t\t\t\tallGroupIds.push(...groupIds);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allGroupIds.length > 0) {\n\t\tconst body = allGroupIds.map((group) => ({\n\t\t\tgroupId: group,\n\t\t\taddOwners: [{ type: 'USER', id: newOwnerId }],\n\t\t\tremoveOwners: [{ type: 'USER', id: userId }]\n\t\t}));\n\n\t\tawait handleRequest('PUT', '/api/content/v2/groups/access', body);\n\n\t\tawait logTransfers(userId, newOwnerId, 'GROUP', allGroupIds);\n\t}\n}\n\n//-----------------------------------------AppDB--------------------------------//\n// Datastore owner cannot be updated\n\nasync function transferAppDbCollections(userId, newOwnerId, filteredIds = []) {\n\tlet allCollectionIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tallCollectionIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet moreData = true;\n\t\tlet pageNumber = 1;\n\t\tconst pageSize = 100;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tcollectionFilteringList: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfilterType: 'ownedby',\n\t\t\t\t\t\tcomparingCriteria: 'equals',\n\t\t\t\t\t\ttypedValue: userId\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tpageSize: pageSize,\n\t\t\t\tpageNumber: pageNumber\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/datastores/v1/collections/query',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response.collections && response.collections.length > 0) {\n\t\t\t\tconst collectionIds = response.collections.map(\n\t\t\t\t\t(collection) => collection.id\n\t\t\t\t);\n\t\t\t\tallCollectionIds.push(...collectionIds);\n\n\t\t\t\t// Increment page number to get next page\n\t\t\t\tpageNumber++;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.collections.length < pageSize) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allCollectionIds.length > 0) {\n\t\tfor (let i = 0; i < allCollectionIds.length; i++) {\n\t\t\tconst url = `/api/datastores/v1/collections/${allCollectionIds[i]}`;\n\t\t\tconst body = { id: allCollectionIds[i], owner: newOwnerId };\n\t\t\tawait handleRequest('PUT', url, body);\n\t\t}\n\t\tawait logTransfers(userId, newOwnerId, 'COLLECTION', allCollectionIds);\n\t}\n}\n\n//--------------------------Functions (Beast Modes and Variables)-------------------------//\n// Need to update to delete Beast Modes on deleted DataSets that have 0 dependencies\n// Helper: verify referenced resources exist; if not, drop links before update\nasync function resourceExists(type, id) {\n\ttry {\n\t\tif (type === 'CARD') {\n\t\t\tawait handleRequest('GET', `/api/content/v1/cards/${id}/details`);\n\t\t\treturn true;\n\t\t}\n\t\tif (type === 'DATA_SOURCE' || type === 'DATASET') {\n\t\t\tawait handleRequest('GET', `/api/data/v3/datasources/${id}`);\n\t\t\treturn true;\n\t\t}\n\t\t// For other types, don't validate here\n\t\treturn true;\n\t} catch (_err) {\n\t\treturn false;\n\t}\n}\n\nasync function sanitizeLinks(links) {\n\tif (!Array.isArray(links) || links.length === 0)\n\t\treturn { valid: [], invalid: [] };\n\tconst valid = [];\n\tconst invalid = [];\n\tfor (const link of links) {\n\t\ttry {\n\t\t\tconst res = link && link.resource ? link.resource : null;\n\t\t\tif (\n\t\t\t\tres &&\n\t\t\t\tres.id != null &&\n\t\t\t\t(res.type === 'CARD' ||\n\t\t\t\t\tres.type === 'DATA_SOURCE' ||\n\t\t\t\t\tres.type === 'DATASET')\n\t\t\t) {\n\t\t\t\tconst exists = await resourceExists(res.type, res.id);\n\t\t\t\tif (!exists) {\n\t\t\t\t\tinvalid.push(link);\n\t\t\t\t\tcontinue; // skip invalid references\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalid.push(link);\n\t\t} catch (_e) {\n\t\t\t// On unexpected shape, drop link\n\t\t\tinvalid.push(link);\n\t\t}\n\t}\n\treturn { valid, invalid };\n}\nasync function transferFunctions(userId, newOwnerId, filteredIds = []) {\n\tlet allFunctionIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list - we need to fetch each function individually\n\t\tconst bulkUrl = '/api/query/v1/functions/bulk/template';\n\t\tconst beastModes = [];\n\t\tconst variables = [];\n\t\tconst deletedBeastModes = [];\n\t\tconst deletedVariables = [];\n\n\t\tfor (const functionId of filteredIds) {\n\t\t\ttry {\n\t\t\t\tconst response = await handleRequest(\n\t\t\t\t\t'GET',\n\t\t\t\t\t`/api/query/v1/functions/template/${functionId}?hidden=true`\n\t\t\t\t);\n\n\t\t\t\tconst originalLinks = response.links;\n\t\t\t\tconst { valid: validLinks, invalid: invalidLinks } =\n\t\t\t\t\tawait sanitizeLinks(originalLinks);\n\n\t\t\t\t// Check if any invalid links are visible\n\t\t\t\tconst hasInvalidVisibleLink = invalidLinks.some(\n\t\t\t\t\t(link) => link.visible === true\n\t\t\t\t);\n\n\t\t\t\t// If function has only one link and it's invalid, OR has any invalid visible link, delete the function\n\t\t\t\tif (\n\t\t\t\t\t(originalLinks &&\n\t\t\t\t\t\toriginalLinks.length === 1 &&\n\t\t\t\t\t\tinvalidLinks.length === 1 &&\n\t\t\t\t\t\tvalidLinks.length === 0) ||\n\t\t\t\t\thasInvalidVisibleLink\n\t\t\t\t) {\n\t\t\t\t\tconst deleteUrl = `/api/query/v1/functions/template/${functionId}`;\n\t\t\t\t\tawait handleRequest('DELETE', deleteUrl);\n\n\t\t\t\t\tif (response.global === false) {\n\t\t\t\t\t\tdeletedBeastModes.push(functionId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeletedVariables.push(functionId);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue; // Skip adding to transfer list\n\t\t\t\t}\n\n\t\t\t\t// Update links individually if there are invalid links to remove\n\t\t\t\tif (invalidLinks.length > 0) {\n\t\t\t\t\tconst linkUrl = `/api/query/v1/functions/template/${functionId}/links`;\n\t\t\t\t\tconst linkBody = {\n\t\t\t\t\t\tlinkTo: validLinks,\n\t\t\t\t\t\tunlinkFrom: invalidLinks\n\t\t\t\t\t};\n\t\t\t\t\tawait handleRequest('POST', linkUrl, linkBody);\n\t\t\t\t}\n\n\t\t\t\tconst functionData = {\n\t\t\t\t\tid: functionId,\n\t\t\t\t\towner: newOwnerId,\n\t\t\t\t\tlinks: validLinks\n\t\t\t\t};\n\n\t\t\t\tif (response.global === false) {\n\t\t\t\t\tbeastModes.push(functionData);\n\t\t\t\t} else {\n\t\t\t\t\tvariables.push(functionData);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Failed to process function ${functionId}:`, error);\n\t\t\t}\n\t\t}\n\n\t\t// Transfer functions in batches\n\t\tconst chunkSize = 100;\n\t\tfor (let i = 0; i < beastModes.length; i += chunkSize) {\n\t\t\tconst chunk = beastModes.slice(i, i + chunkSize);\n\t\t\tawait handleRequest('POST', bulkUrl, { update: chunk });\n\t\t}\n\t\tfor (let i = 0; i < variables.length; i += chunkSize) {\n\t\t\tconst chunk = variables.slice(i, i + chunkSize);\n\t\t\tawait handleRequest('POST', bulkUrl, { update: chunk });\n\t\t}\n\n\t\t// Log results\n\t\tif (beastModes.length > 0) {\n\t\t\tawait logTransfers(\n\t\t\t\tuserId,\n\t\t\t\tnewOwnerId,\n\t\t\t\t'BEAST_MODE_FORMULA',\n\t\t\t\tbeastModes.map((func) => func.id)\n\t\t\t);\n\t\t}\n\t\tif (variables.length > 0) {\n\t\t\tawait logTransfers(\n\t\t\t\tuserId,\n\t\t\t\tnewOwnerId,\n\t\t\t\t'VARIABLE',\n\t\t\t\tvariables.map((func) => func.id)\n\t\t\t);\n\t\t}\n\t\tif (deletedBeastModes.length > 0) {\n\t\t\tawait logTransfers(\n\t\t\t\tuserId,\n\t\t\t\tnewOwnerId,\n\t\t\t\t'BEAST_MODE_FORMULA',\n\t\t\t\tdeletedBeastModes,\n\t\t\t\t'DELETED',\n\t\t\t\t'Beast Mode was linked to deleted or inaccessible resources'\n\t\t\t);\n\t\t}\n\t\tif (deletedVariables.length > 0) {\n\t\t\tawait logTransfers(\n\t\t\t\tuserId,\n\t\t\t\tnewOwnerId,\n\t\t\t\t'VARIABLE',\n\t\t\t\tdeletedVariables,\n\t\t\t\t'DELETED',\n\t\t\t\t'Variable was linked to deleted or inaccessible resources'\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet moreData = true;\n\t\tlet offset = 0;\n\t\tconst limit = 100;\n\t\tconst chunkSize = 100; // Max objects per transfer request\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tfilters: [{ field: 'owner', idList: [userId] }],\n\t\t\t\tsort: {\n\t\t\t\t\tfield: 'name',\n\t\t\t\t\tascending: true\n\t\t\t\t},\n\t\t\t\tlimit: limit,\n\t\t\t\toffset: offset\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/query/v1/functions/search',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tconst bulkUrl = '/api/query/v1/functions/bulk/template';\n\t\t\tif (response.results && response.results.length > 0) {\n\t\t\t\t// Process beast modes\n\t\t\t\tconst beastModesRaw = response.results.filter(\n\t\t\t\t\t(func) => func.global === false\n\t\t\t\t);\n\t\t\t\tconst beastModes = [];\n\t\t\t\tconst deletedBeastModes = [];\n\n\t\t\t\tfor (const beastMode of beastModesRaw) {\n\t\t\t\t\tconst originalLinks = beastMode.links;\n\t\t\t\t\tconst { valid: validLinks, invalid: invalidLinks } =\n\t\t\t\t\t\tawait sanitizeLinks(originalLinks);\n\n\t\t\t\t\t// Check if any invalid links are visible\n\t\t\t\t\tconst hasInvalidVisibleLink = invalidLinks.some(\n\t\t\t\t\t\t(link) => link.visible === true\n\t\t\t\t\t);\n\n\t\t\t\t\t// If function has only one link and it's invalid, OR has any invalid visible link, delete the function\n\t\t\t\t\tif (\n\t\t\t\t\t\t(originalLinks &&\n\t\t\t\t\t\t\toriginalLinks.length === 1 &&\n\t\t\t\t\t\t\tinvalidLinks.length === 1 &&\n\t\t\t\t\t\t\tvalidLinks.length === 0) ||\n\t\t\t\t\t\thasInvalidVisibleLink\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst deleteUrl = `/api/query/v1/functions/template/${beastMode.id}`;\n\t\t\t\t\t\tawait handleRequest('DELETE', deleteUrl);\n\t\t\t\t\t\tdeletedBeastModes.push(beastMode.id);\n\t\t\t\t\t\tcontinue; // Skip adding to transfer list\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update links individually if there are invalid links to remove\n\t\t\t\t\tif (invalidLinks.length > 0) {\n\t\t\t\t\t\tconst linkUrl = `/api/query/v1/functions/template/${beastMode.id}/links`;\n\t\t\t\t\t\tconst linkBody = {\n\t\t\t\t\t\t\tlinkTo: validLinks,\n\t\t\t\t\t\t\tunlinkFrom: invalidLinks\n\t\t\t\t\t\t};\n\t\t\t\t\t\tawait handleRequest('POST', linkUrl, linkBody);\n\t\t\t\t\t}\n\n\t\t\t\t\tbeastModes.push({\n\t\t\t\t\t\tid: beastMode.id,\n\t\t\t\t\t\towner: newOwnerId,\n\t\t\t\t\t\tlinks: validLinks\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Transfer beast modes in batches of 100\n\t\t\t\tfor (let i = 0; i < beastModes.length; i += chunkSize) {\n\t\t\t\t\tconst chunk = beastModes.slice(i, i + chunkSize);\n\t\t\t\t\tawait handleRequest('POST', bulkUrl, { update: chunk });\n\t\t\t\t}\n\n\t\t\t\t// Log transferred beast modes\n\t\t\t\tif (beastModes.length > 0) {\n\t\t\t\t\tawait logTransfers(\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tnewOwnerId,\n\t\t\t\t\t\t'BEAST_MODE_FORMULA',\n\t\t\t\t\t\tbeastModes.map((func) => func.id)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Log deleted beast modes\n\t\t\t\tif (deletedBeastModes.length > 0) {\n\t\t\t\t\tawait logTransfers(\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tnewOwnerId,\n\t\t\t\t\t\t'BEAST_MODE_FORMULA',\n\t\t\t\t\t\tdeletedBeastModes,\n\t\t\t\t\t\t'DELETED',\n\t\t\t\t\t\t'Beast Mode was linked to deleted or inaccessible resources'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Process variables\n\t\t\t\tconst variablesRaw = response.results.filter(\n\t\t\t\t\t(func) => func.global === true\n\t\t\t\t);\n\t\t\t\tconst variables = [];\n\t\t\t\tconst deletedVariables = [];\n\n\t\t\t\tfor (const variable of variablesRaw) {\n\t\t\t\t\tconst originalLinks = variable.links;\n\t\t\t\t\tconst { valid: validLinks, invalid: invalidLinks } =\n\t\t\t\t\t\tawait sanitizeLinks(originalLinks);\n\n\t\t\t\t\t// Check if any invalid links are visible\n\t\t\t\t\tconst hasInvalidVisibleLink = invalidLinks.some(\n\t\t\t\t\t\t(link) => link.visible === true\n\t\t\t\t\t);\n\n\t\t\t\t\t// If function has only one link and it's invalid, OR has any invalid visible link, delete the function\n\t\t\t\t\tif (\n\t\t\t\t\t\t(originalLinks &&\n\t\t\t\t\t\t\toriginalLinks.length === 1 &&\n\t\t\t\t\t\t\tinvalidLinks.length === 1 &&\n\t\t\t\t\t\t\tvalidLinks.length === 0) ||\n\t\t\t\t\t\thasInvalidVisibleLink\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst deleteUrl = `/api/query/v1/functions/template/${variable.id}`;\n\t\t\t\t\t\tawait handleRequest('DELETE', deleteUrl);\n\t\t\t\t\t\tdeletedVariables.push(variable.id);\n\t\t\t\t\t\tcontinue; // Skip adding to transfer list\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update links individually if there are invalid links to remove\n\t\t\t\t\tif (invalidLinks.length > 0) {\n\t\t\t\t\t\tconst linkUrl = `/api/query/v1/functions/template/${variable.id}/links`;\n\t\t\t\t\t\tconst linkBody = {\n\t\t\t\t\t\t\tlinkTo: validLinks,\n\t\t\t\t\t\t\tunlinkFrom: invalidLinks\n\t\t\t\t\t\t};\n\t\t\t\t\t\tawait handleRequest('POST', linkUrl, linkBody);\n\t\t\t\t\t}\n\n\t\t\t\t\tvariables.push({\n\t\t\t\t\t\tid: variable.id,\n\t\t\t\t\t\towner: newOwnerId,\n\t\t\t\t\t\tlinks: validLinks\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Transfer variables in batches of 100\n\t\t\t\tfor (let i = 0; i < variables.length; i += chunkSize) {\n\t\t\t\t\tconst chunk = variables.slice(i, i + chunkSize);\n\t\t\t\t\tawait handleRequest('POST', bulkUrl, { update: chunk });\n\t\t\t\t}\n\n\t\t\t\t// Log transferred variables\n\t\t\t\tif (variables.length > 0) {\n\t\t\t\t\tawait logTransfers(\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tnewOwnerId,\n\t\t\t\t\t\t'VARIABLE',\n\t\t\t\t\t\tvariables.map((func) => func.id)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Log deleted variables\n\t\t\t\tif (deletedVariables.length > 0) {\n\t\t\t\t\tawait logTransfers(\n\t\t\t\t\t\tuserId,\n\t\t\t\t\t\tnewOwnerId,\n\t\t\t\t\t\t'VARIABLE',\n\t\t\t\t\t\tdeletedVariables,\n\t\t\t\t\t\t'DELETED',\n\t\t\t\t\t\t'Variable was linked to deleted or inaccessible resources'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\tmoreData = response.hasMore;\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//-----------------------------Accounts---------------------//\n\nasync function transferAccounts(userId, newOwnerId, filteredIds = []) {\n\tlet accountIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\taccountIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet moreData = true;\n\t\tlet offset = 0;\n\t\tconst count = 100;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tcount: count,\n\t\t\t\toffset: offset,\n\t\t\t\tcombineResults: false,\n\t\t\t\thideSearchObjects: true,\n\t\t\t\tquery: '**',\n\t\t\t\tfilters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfilterType: 'term',\n\t\t\t\t\t\tfield: 'owned_by_id',\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\tname: 'Owned by',\n\t\t\t\t\t\tnot: false\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tfacetValuesToInclude: [],\n\t\t\t\tqueryProfile: 'GLOBAL',\n\t\t\t\tentityList: [['account']]\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/search/v1/query',\n\t\t\t\tdata\n\t\t\t);\n\t\t\tif (\n\t\t\t\tresponse.searchResultsMap &&\n\t\t\t\tresponse.searchResultsMap.account.length > 0\n\t\t\t) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.searchResultsMap.account.map(\n\t\t\t\t\t(account) => account.databaseId\n\t\t\t\t);\n\t\t\t\taccountIds.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += count;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.searchResultsMap.account.length < count) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (accountIds.length > 0) {\n\t\tfor (let i = 0; i < accountIds.length; i++) {\n\t\t\tconst transferUrl = `/api/data/v2/accounts/share/${accountIds[i]}`;\n\t\t\tconst addBody = { type: 'USER', id: newOwnerId, accessLevel: 'OWNER' };\n\t\t\tawait handleRequest('PUT', transferUrl, addBody);\n\n\t\t\t// Removed because their access will be removed when they are deleted\n\t\t\t// const removeBody = { type: 'USER', id: userId, accessLevel: 'NONE' };\n\t\t\t// await handleRequest('PUT', transferUrl, removeBody);\n\t\t}\n\n\t\tawait logTransfers(userId, newOwnerId, 'ACCOUNT', accountIds);\n\t}\n}\n\n//---------------------------Jupyter Workspaces---------------------//\n\nasync function transferJupyterWorkspaces(userId, newOwnerId, filteredIds = []) {\n\tlet jupyterWorkspaceIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tjupyterWorkspaceIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet moreData = true;\n\t\tlet offset = 0;\n\t\tconst limit = 100;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tsortFieldMap: {\n\t\t\t\t\tLAST_RUN: 'DESC'\n\t\t\t\t},\n\t\t\t\tsearchFieldMap: {},\n\t\t\t\tfilters: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'OWNER',\n\t\t\t\t\t\tvalues: [userId]\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\toffset: offset,\n\t\t\t\tlimit: limit\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/datascience/v1/search/workspaces',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response.workspaces && response.workspaces.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.workspaces.map((workspace) => workspace.id);\n\t\t\t\tjupyterWorkspaceIds.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.workspaces.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (jupyterWorkspaceIds.length > 0) {\n\t\tfor (let i = 0; i < jupyterWorkspaceIds.length; i++) {\n\t\t\tconst url = `/api/datascience/v1/workspaces/${jupyterWorkspaceIds[i]}/ownership`;\n\t\t\tawait handleRequest('PUT', url, { newOwnerId });\n\t\t}\n\t\tawait logTransfers(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\t'DATA_SCIENCE_NOTEBOOK',\n\t\t\tjupyterWorkspaceIds\n\t\t);\n\t}\n}\n\n//------------------------------Code Engine Packages--------------------------//\n\nasync function transferCodeEnginePackages(\n\tuserId,\n\tnewOwnerId,\n\tfilteredIds = []\n) {\n\tlet codeEnginePackageIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tcodeEnginePackageIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet moreData = true;\n\t\tlet offset = 0;\n\t\tconst count = 100;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tquery: '**',\n\t\t\t\tentityList: [['package']],\n\t\t\t\tcount: count,\n\t\t\t\toffset: offset,\n\t\t\t\tfilters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: 'owned_by_id',\n\t\t\t\t\t\tfilterType: 'term',\n\t\t\t\t\t\tvalue: `${userId}:USER`\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\thideSearchObjects: true,\n\t\t\t\tfacetValuesToInclude: []\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/search/v1/query',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\tresponse.searchResultsMap.package &&\n\t\t\t\tresponse.searchResultsMap.package.length > 0\n\t\t\t) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.searchResultsMap.package.map(\n\t\t\t\t\t(codeEngine) => codeEngine.uuid\n\t\t\t\t);\n\t\t\t\tcodeEnginePackageIds.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += count;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.searchResultsMap.package.length < count) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (codeEnginePackageIds.length > 0) {\n\t\tfor (let i = 0; i < codeEnginePackageIds.length; i++) {\n\t\t\tconst url = `/api/codeengine/v2/packages/${codeEnginePackageIds[i]}`;\n\t\t\tawait handleRequest('PUT', url, { owner: parseInt(newOwnerId) });\n\t\t}\n\t\tawait logTransfers(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\t'CODEENGINE_PACKAGE',\n\t\t\tcodeEnginePackageIds\n\t\t);\n\t}\n}\n\n//---------------------------------------FileSets--------------------------------------------//\n\nasync function transferFilesets(userId, newOwnerId, filteredIds = []) {\n\tlet filesetIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tfilesetIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet moreData = true;\n\t\tlet offset = 0;\n\t\tconst limit = 100;\n\n\t\tconst data = {\n\t\t\tfilters: [\n\t\t\t\t{\n\t\t\t\t\tfield: 'owner',\n\t\t\t\t\tvalue: [userId],\n\t\t\t\t\tnot: false,\n\t\t\t\t\toperator: 'EQUALS'\n\t\t\t\t}\n\t\t\t],\n\t\t\tfieldSort: [\n\t\t\t\t{\n\t\t\t\t\tfield: 'updated',\n\t\t\t\t\torder: 'DESC'\n\t\t\t\t}\n\t\t\t],\n\t\t\tdateFilters: []\n\t\t};\n\n\t\twhile (moreData) {\n\t\t\tconst url = `/api/files/v1/filesets/search?offset=${offset}&limit=${limit}`;\n\t\t\tconst response = await handleRequest('POST', url, data);\n\n\t\t\tif (response.filesets && response.filesets.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.filesets.map((fileset) => fileset.id);\n\t\t\t\tfilesetIds.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.filesets.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (filesetIds.length > 0) {\n\t\tfor (let i = 0; i < filesetIds.length; i++) {\n\t\t\tconst url = `/api/files/v1/filesets/${filesetIds[i]}/ownership`;\n\t\t\tawait handleRequest('POST', url, { userId: parseInt(newOwnerId) });\n\t\t}\n\t\tawait logTransfers(userId, newOwnerId, 'FILESET', filesetIds);\n\t}\n}\n\n//--------------------------------------Domo Everywhere Publications------------------------------------------//\n\n// Limitation the new owner must be an owner of all the content\n// Just get a list of publications for the manager to review\n\nasync function getPublications(userId, newOwnerId) {\n\tlet publications = [];\n\tconst url = '/api/publish/v2/publications';\n\n\tconst response = await handleRequest('GET', url);\n\tif (response && response.length > 0) {\n\t\tfor (let i = 0; i < response.length; i++) {\n\t\t\tconst publicationId = response[i].id;\n\t\t\tconst publicationUrl = `/api/publish/v2/publications/${publicationId}`;\n\t\t\tconst response2 = await handleRequest('GET', publicationUrl);\n\t\t\tif (response2.content.userId == userId) {\n\t\t\t\tpublications.push(publicationId);\n\t\t\t}\n\t\t}\n\t}\n\n\tawait logTransfers(\n\t\tuserId,\n\t\tnewOwnerId,\n\t\t'PUBLICATION',\n\t\tpublications,\n\t\t'NOT_TRANSFERRED',\n\t\t'Publications cannot be transferred as the new owner must be an owner of all the content'\n\t);\n}\n\n//-------------------------------------Domo Everywhere Subscriptions-----------------------------------------//\n\nasync function transferSubscriptions(userId, newOwnerId, filteredIds = []) {\n\tlet subscriptionIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tfor (const subscriptionId of filteredIds) {\n\t\t\ttry {\n\t\t\t\tconst subscriptionUrl = `api/publish/v2/subscriptions/${subscriptionId}/share`;\n\t\t\t\tconst subscription = await handleRequest('GET', subscriptionUrl);\n\n\t\t\t\tif (subscription.userId == userId) {\n\t\t\t\t\tconst url = `/api/publish/v2/subscriptions/${subscription.subscription.id}`;\n\t\t\t\t\tconst body = {\n\t\t\t\t\t\tpublicationId: subscription.subscription.publicationId,\n\t\t\t\t\t\tdomain: subscription.subscription.domain,\n\t\t\t\t\t\tcustomerId: subscription.subscription.customerId,\n\t\t\t\t\t\tuserId: newOwnerId,\n\t\t\t\t\t\tuserIds: subscription.shareUsers,\n\t\t\t\t\t\tgroupIds: subscription.shareGroups\n\t\t\t\t\t};\n\t\t\t\t\tawait handleRequest('PUT', url, body);\n\t\t\t\t\tsubscriptionIds.push(subscription.subscription.id);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`Failed to transfer subscription ${subscriptionId}:`,\n\t\t\t\t\terror\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst limit = 40;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\t\tlet subscriptions = [];\n\n\t\twhile (moreData) {\n\t\t\tconst url = 'api/publish/v2/subscriptions/summaries';\n\t\t\tconst response = await handleRequest('GET', url);\n\n\t\t\tif (response && response.length > 0) {\n\t\t\t\tsubscriptions.push(...response);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\t// If less than limit returned, this is the last page\n\t\t\t\tif (response.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < subscriptions.length; i++) {\n\t\t\tconst subscriptionUrl = `api/publish/v2/subscriptions/${subscriptions[i].subscriptionId}/share`;\n\t\t\tconst subscription = await handleRequest('GET', subscriptionUrl);\n\n\t\t\tif (subscription.userId == userId) {\n\t\t\t\tsubscriptionIds.push(subscription.subscription.id);\n\t\t\t\tconst url = `/api/publish/v2/subscriptions/${subscription.subscription.id}`;\n\t\t\t\tconst body = {\n\t\t\t\t\tpublicationId: subscription.subscription.publicationId,\n\t\t\t\t\tdomain: subscription.subscription.domain,\n\t\t\t\t\tcustomerId: subscription.subscription.customerId,\n\t\t\t\t\tuserId: newOwnerId,\n\t\t\t\t\tuserIds: subscription.shareUsers,\n\t\t\t\t\tgroupIds: subscription.shareGroups\n\t\t\t\t};\n\t\t\t\tawait handleRequest('PUT', url, body);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (subscriptionIds.length > 0) {\n\t\tawait logTransfers(userId, newOwnerId, 'SUBSCRIPTION', subscriptionIds);\n\t}\n}\n\n//--------------------------------------------------Sandbox Repositories---------------------------------//\n\nasync function transferRepositories(userId, newOwnerId, filteredIds = []) {\n\tlet repositoryIds = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\trepositoryIds = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst limit = 50;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tquery: {\n\t\t\t\t\toffset: offset,\n\t\t\t\t\tlimit: limit,\n\t\t\t\t\tfieldSearchMap: {},\n\t\t\t\t\tsort: 'lastCommit',\n\t\t\t\t\torder: 'desc',\n\t\t\t\t\tfilters: { userId: [userId] },\n\t\t\t\t\tdateFilters: {}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/version/v1/repositories/search',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response.repositories && response.repositories.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.repositories.map((repository) => repository.id);\n\t\t\t\trepositoryIds.push(...ids);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.repositories.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (repositoryIds.length > 0) {\n\t\tfor (let i = 0; i < repositoryIds.length; i++) {\n\t\t\tconst url = `/api/version/v1/repositories/${repositoryIds[i]}/permissions`;\n\n\t\t\tconst body = {\n\t\t\t\trepositoryPermissionUpdates: [\n\t\t\t\t\t{\n\t\t\t\t\t\tuserId: newOwnerId,\n\t\t\t\t\t\tpermission: 'OWNER'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tuserId: userId,\n\t\t\t\t\t\tpermission: 'NONE'\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\n\t\t\tawait handleRequest('POST', url, body);\n\t\t}\n\t\tawait logTransfers(userId, newOwnerId, 'REPOSITORY', repositoryIds);\n\t}\n}\n\n//-----------------------------------------Approvals--------------------------------------//\n\nasync function transferApprovals(userId, newOwnerId) {\n\t// Use existing discovery logic\n\tconst url = '/api/synapse/approval/graphql';\n\n\tconst data = {\n\t\toperationName: 'getFilteredRequests',\n\t\tvariables: {\n\t\t\tquery: {\n\t\t\t\tactive: true,\n\t\t\t\tsubmitterId: null,\n\t\t\t\tapproverId: userId,\n\t\t\t\ttemplateId: null,\n\t\t\t\ttitle: null,\n\t\t\t\tlastModifiedBefore: null\n\t\t\t},\n\t\t\tafter: null,\n\t\t\treverseSort: false\n\t\t},\n\t\tquery:\n\t\t\t'query getFilteredRequests($query: QueryRequest!, $after: ID, $reverseSort: Boolean) {\\n  workflowSearch(query: $query, type: \"AC\", after: $after, reverseSort: $reverseSort) {\\n    edges {\\n      cursor\\n      node {\\n        approval {\\n          id\\n          title\\n          templateTitle\\n          status\\n          modifiedTime\\n          version\\n          providerName\\n          approvalChainIdx\\n          pendingApprover: pendingApproverEx {\\n            id\\n            type\\n            displayName\\n            ... on User {\\n              title\\n              avatarKey\\n              __typename\\n            }\\n            ... on Group {\\n              isDeleted\\n              __typename\\n            }\\n            __typename\\n          }\\n          submitter {\\n            id\\n            type\\n            displayName\\n            avatarKey\\n            isCurrentUser\\n            __typename\\n          }\\n          __typename\\n        }\\n        __typename\\n      }\\n      __typename\\n    }\\n    pageInfo {\\n      hasNextPage\\n      hasPreviousPage\\n      startCursor\\n      endCursor\\n      __typename\\n    }\\n    __typename\\n  }\\n}\\n'\n\t};\n\n\tconst response = await handleRequest('POST', url, data);\n\tconst responseApprovals = response.data.workflowSearch.edges;\n\n\tconst pendingApprovals = responseApprovals.filter(\n\t\t(approval) => approval.node.approval.status === 'PENDING'\n\t);\n\n\tconst sentBackApprovals = responseApprovals.filter(\n\t\t(approval) => approval.node.approval.status === 'SENTBACK'\n\t);\n\n\tfor (let i = 0; i < pendingApprovals.length; i++) {\n\t\tif (pendingApprovals[i].node.approval.status == 'PENDING') {\n\t\t\tconst approvalId = pendingApprovals[i].node.approval.id;\n\t\t\tconst version = pendingApprovals[i].node.approval.version;\n\n\t\t\tconst transferBody = {\n\t\t\t\toperationName: 'replaceApprovers',\n\t\t\t\tvariables: {\n\t\t\t\t\tactedOnApprovals: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: approvalId,\n\t\t\t\t\t\t\tversion: version\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\tnewApproverId: newOwnerId,\n\t\t\t\t\tnewApproverType: 'PERSON'\n\t\t\t\t},\n\t\t\t\tquery:\n\t\t\t\t\t'mutation replaceApprovers($actedOnApprovals: [ActedOnApprovalInput!]!, $newApproverId: ID!, $newApproverType: ApproverType) {\\n  bulkReplaceApprover(actedOnApprovals: $actedOnApprovals, newApproverId: $newApproverId, newApproverType: $newApproverType) {\\n    id\\n    __typename\\n  }\\n}\\n'\n\t\t\t};\n\n\t\t\tawait handleRequest('POST', url, transferBody);\n\t\t}\n\t}\n\n\tif (pendingApprovals.length > 0) {\n\t\tawait logTransfers(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\t'APPROVAL',\n\t\t\tpendingApprovals.map((approval) => approval.node.approval.id)\n\t\t);\n\t}\n\n\tif (sentBackApprovals.length > 0) {\n\t\tawait logTransfers(\n\t\t\tuserId,\n\t\t\tnewOwnerId,\n\t\t\t'APPROVAL',\n\t\t\tsentBackApprovals.map((approval) => approval.node.approval.id),\n\t\t\t'NOT_TRANSFERRED',\n\t\t\t'Transferring of sent back approvals is not supported'\n\t\t);\n\t}\n}\n\n//-----------------------------------------Approval Templates--------------------------------------//\n\nasync function transferApprovalTemplates(userId, newOwnerId) {\n\t// Use existing discovery logic\n\tconst url = '/api/synapse/approval/graphql';\n\n\tconst searchTemplatesBody = {\n\t\toperationName: 'getFilteredTemplates',\n\t\tvariables: {\n\t\t\tfirst: 100,\n\t\t\tafter: null,\n\t\t\torderBy: 'TEMPLATE',\n\t\t\treverseSort: false,\n\t\t\tquery: {\n\t\t\t\ttype: 'AC',\n\t\t\t\tsearchTerm: '',\n\t\t\t\tcategory: [],\n\t\t\t\townerId: userId,\n\t\t\t\tpublishedOnly: false\n\t\t\t}\n\t\t},\n\t\tquery: `query getFilteredTemplates(\n\t\t  $first: Int\n\t\t  $after: ID\n\t\t  $orderBy: OrderBy\n\t\t  $reverseSort: Boolean\n\t\t  $query: TemplateQueryRequest!\n\t\t) {\n\t\t  templateConnection(\n\t\t    first: $first\n\t\t    after: $after\n\t\t    orderBy: $orderBy\n\t\t    reverseSort: $reverseSort\n\t\t    query: $query\n\t\t  ) {\n\t\t    edges {\n\t\t      cursor\n\t\t      node {\n\t\t        id\n\t\t      }\n\t\t    }\n\t\t    pageInfo {\n\t\t      hasNextPage\n\t\t      hasPreviousPage\n\t\t      startCursor\n\t\t      endCursor\n\t\t    }\n\t\t  }\n\t\t}`\n\t};\n\n\tconst searchTemplatesResponse = await handleRequest(\n\t\t'POST',\n\t\turl,\n\t\tsearchTemplatesBody\n\t);\n\n\tif (searchTemplatesResponse.data.templateConnection.edges.length > 0) {\n\t\tconst approvalTemplateIds =\n\t\t\tsearchTemplatesResponse.data.templateConnection.edges.map(\n\t\t\t\t(edge) => edge.node.id\n\t\t\t);\n\n\t\tlet getTemplateBody = {\n\t\t\toperationName: 'getTemplateForEdit',\n\t\t\tvariables: {\n\t\t\t\tid: null\n\t\t\t},\n\t\t\tquery: `query getTemplateForEdit($id: ID!) {\n\t\t\t\ttemplate(id: $id) {\n\t\t\t\t\tid\n\t\t\t\t\ttitle\n\t\t\t\t\tacknowledgment\n\t\t\t\t\tdescription\n\t\t\t\t\tproviderName\n\t\t\t\t\tisPublic\n\t\t\t\t\tchainIsLocked\n\t\t\t\t\tobservers {\n\t\t\t\t\t\tid\n\t\t\t\t\t\ttype\n\t\t\t\t\t\tdisplayName\n\t\t\t\t\t\tavatarKey\n\t\t\t\t\t\ttitle\n\t\t\t\t\t\t... on Group {\n\t\t\t\t\t\t\tuserCount\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcategories {\n\t\t\t\t\t\tid\n\t\t\t\t\t}\n\t\t\t\t\tfields {\n\t\t\t\t\t\tkey\n\t\t\t\t\t\ttype\n\t\t\t\t\t\tname\n\t\t\t\t\t\tdata\n\t\t\t\t\t\tplaceholder\n\t\t\t\t\t\trequired\n\t\t\t\t\t\tisPrivate\n\t\t\t\t\t\t... on SelectField {\n\t\t\t\t\t\t\toption\n\t\t\t\t\t\t\tmultiselect\n\t\t\t\t\t\t\tdatasource\n\t\t\t\t\t\t\tcolumn\n\t\t\t\t\t\t\torder\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tapprovers {\n\t\t\t\t\t\ttype\n\t\t\t\t\t\toriginalType: type\n\t\t\t\t\t\tkey\n\t\t\t\t\t\t... on ApproverPerson {\n\t\t\t\t\t\t\tid: approverId\n\t\t\t\t\t\t\tapproverId\n\t\t\t\t\t\t\tuserDetails {\n\t\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\t\tdisplayName\n\t\t\t\t\t\t\t\ttitle\n\t\t\t\t\t\t\t\tavatarKey\n\t\t\t\t\t\t\t\tisDeleted\n\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on ApproverGroup {\n\t\t\t\t\t\t\tid: approverId\n\t\t\t\t\t\t\tapproverId\n\t\t\t\t\t\t\tgroupDetails {\n\t\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\t\tdisplayName\n\t\t\t\t\t\t\t\tuserCount\n\t\t\t\t\t\t\t\tisDeleted\n\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on ApproverPlaceholder {\n\t\t\t\t\t\t\tplaceholderText\n\t\t\t\t\t\t}\n\t\t\t\t\t\t__typename\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`\n\t\t};\n\n\t\t// For each templateget full details, update owner, approvers, and observersthen save\n\t\tfor (let i = 0; i < approvalTemplateIds.length; i++) {\n\t\t\tgetTemplateBody.variables.id = approvalTemplateIds[i];\n\t\t\tconst getTemplateResponse = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\turl,\n\t\t\t\tgetTemplateBody\n\t\t\t);\n\t\t\tlet template = getTemplateResponse.data.template;\n\t\t\ttemplate.ownerId = newOwnerId;\n\n\t\t\t// Update approvers: if user is an approver, replace with new owner (only id, approverId, and type are required)\n\t\t\tif (Array.isArray(template.approvers) && template.approvers.length > 0) {\n\t\t\t\ttemplate.approvers = template.approvers.map((approver) =>\n\t\t\t\t\tapprover.type === 'PERSON' &&\n\t\t\t\t\t(approver.id == userId || approver.approverId == userId)\n\t\t\t\t\t\t? { id: newOwnerId, approverId: newOwnerId, type: 'PERSON' }\n\t\t\t\t\t\t: approver\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Remove duplicate approvers based on id, in case the new owner was already an approver\n\t\t\ttemplate.approvers = template.approvers.filter(\n\t\t\t\t(value, index, self) =>\n\t\t\t\t\tindex === self.findIndex((approver) => approver.id === value.id)\n\t\t\t);\n\n\t\t\t// Update observers: if user is an observer, replace with new owner (only id and type are required)\n\t\t\tif (Array.isArray(template.observers) && template.observers.length > 0) {\n\t\t\t\ttemplate.observers = template.observers.map((observer) =>\n\t\t\t\t\tobserver.type === 'PERSON' && observer.id == userId\n\t\t\t\t\t\t? { id: newOwnerId, type: 'PERSON' }\n\t\t\t\t\t\t: observer\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Remove duplicate observers based on id, in case the new owner was already an observer\n\t\t\ttemplate.observers = template.observers.filter(\n\t\t\t\t(value, index, self) =>\n\t\t\t\t\tindex === self.findIndex((observer) => observer.id === value.id)\n\t\t\t);\n\n\t\t\tconst transferTemplateBody = {\n\t\t\t\toperationName: 'saveTemplate',\n\t\t\t\tvariables: {\n\t\t\t\t\ttemplate: template\n\t\t\t\t},\n\t\t\t\tquery: `mutation saveTemplate($template: TemplateInput!) {\n\t\t\t\t\t\ttemplate: saveTemplate(template: $template) {\n\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\ttitle\n\t\t\t\t\t\t\ttitleName\n\t\t\t\t\t\t\ttitlePlaceholder\n\t\t\t\t\t\t\tacknowledgment\n\t\t\t\t\t\t\tinstructions\n\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\tproviderName\n\t\t\t\t\t\t\tisPublic\n\t\t\t\t\t\t\tchainIsLocked\n\t\t\t\t\t\t\towner {\n\t\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\t\tdisplayName\n\t\t\t\t\t\t\t\tavatarKey\n\t\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tplaceholder\n\t\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\t\tisLocked\n\t\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapprovers {\n\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\toriginalType: type\n\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t... on ApproverPerson {\n\t\t\t\t\t\t\t\tapproverId\n\t\t\t\t\t\t\t\tuserDetails {\n\t\t\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\t\t\tdisplayName\n\t\t\t\t\t\t\t\t\ttitle\n\t\t\t\t\t\t\t\t\tavatarKey\n\t\t\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t... on ApproverGroup {\n\t\t\t\t\t\t\t\tapproverId\n\t\t\t\t\t\t\t\tgroupDetails {\n\t\t\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\t\t\tdisplayName\n\t\t\t\t\t\t\t\t\tuserCount\n\t\t\t\t\t\t\t\t\tisDeleted\n\t\t\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t... on ApproverPlaceholder {\n\t\t\t\t\t\t\t\tplaceholderText\n\t\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t}\n\t\t\t\t\t}`\n\t\t\t};\n\n\t\t\tawait handleRequest('POST', url, transferTemplateBody);\n\t\t}\n\t\tawait logTransfers(userId, newOwnerId, 'TEMPLATE', approvalTemplateIds);\n\t}\n}\n\n//--------------------------------Custom Apps (Bricks and Pro Code Apps)-------------------------------------//\n\nasync function transferCustomApps(userId, newOwnerId, filteredIds = []) {\n\tlet allAppIds = [];\n\tlet bricks = [];\n\tlet proCodeApps = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tallAppIds = filteredIds;\n\n\t\t// We need to check each app to categorize it properly\n\t\tfor (const appId of filteredIds) {\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'GET',\n\t\t\t\t`/api/apps/v1/designs/${appId}?parts=versions`\n\t\t\t);\n\n\t\t\tif (response && response.owner == userId) {\n\t\t\t\tif (\n\t\t\t\t\tresponse.versions &&\n\t\t\t\t\tresponse.versions.length > 0 &&\n\t\t\t\t\tObject(response.versions[0]).hasOwnProperty('flags')\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tObject(response.versions[0].flags).hasOwnProperty(\n\t\t\t\t\t\t\t'client-code-enabled'\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (response.versions[0].flags['client-code-enabled']) {\n\t\t\t\t\t\t\tbricks.push(appId);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tproCodeApps.push(appId);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproCodeApps.push(appId);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tproCodeApps.push(appId);\n\t\t\t\t}\n\n\t\t\t\tconst transferUrl = `/api/apps/v1/designs/${appId}/permissions/ADMIN`;\n\t\t\t\tconst body = [newOwnerId];\n\t\t\t\tawait handleRequest('POST', transferUrl, body);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst limit = 100;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst url = `/api/apps/v1/designs?checkAdminAuthority=true&deleted=false&limit=${limit}&offset=${offset}`;\n\t\t\tconst response = await handleRequest('GET', url);\n\n\t\t\tif (response && response.length > 0) {\n\t\t\t\tfor (let i = 0; i < response.length; i++) {\n\t\t\t\t\tif (response[i].owner == userId) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tresponse[i].versions &&\n\t\t\t\t\t\t\tresponse[i].versions.length > 0 &&\n\t\t\t\t\t\t\tObject(response[i].versions[0]).hasOwnProperty('flags')\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tObject(response[i].versions[0].flags).hasOwnProperty(\n\t\t\t\t\t\t\t\t\t'client-code-enabled'\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (response[i].versions[0].flags['client-code-enabled']) {\n\t\t\t\t\t\t\t\t\tbricks.push(response[i].id);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tproCodeApps.push(response[i].id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tproCodeApps.push(response[i].id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tproCodeApps.push(response[i].id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst transferUrl = `/api/apps/v1/designs/${response[i].id}/permissions/ADMIN`;\n\t\t\t\t\t\tconst body = [newOwnerId];\n\t\t\t\t\t\tawait handleRequest('POST', transferUrl, body);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (response.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\n\t\t\t\toffset += limit;\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bricks.length > 0) {\n\t\tawait logTransfers(userId, newOwnerId, 'APP', bricks);\n\t}\n\tif (proCodeApps.length > 0) {\n\t\tawait logTransfers(userId, newOwnerId, 'RYUU_APP', proCodeApps);\n\t}\n}\n\n//-------------------------------------AI Models--------------------------------//\n\nasync function transferAiModels(userId, newOwnerId, filteredIds = []) {\n\tlet models = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tmodels = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst limit = 50;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tlimit: 50,\n\t\t\t\toffset: 0,\n\t\t\t\tsortFieldMap: {\n\t\t\t\t\tCREATED: 'DESC'\n\t\t\t\t},\n\t\t\t\tsearchFieldMap: { NAME: '' },\n\t\t\t\tfilters: [{ type: 'OWNER', values: [userId] }],\n\t\t\t\tmetricFilters: {},\n\t\t\t\tdateFilters: {},\n\t\t\t\tsortMetricMap: {}\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/datascience/ml/v1/search/models',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response && response.models.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.models.map((model) => model.id);\n\t\t\t\tmodels.push(...ids);\n\n\t\t\t\tif (response.models.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\n\t\t\t\toffset += limit;\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (models.length > 0) {\n\t\tfor (let i = 0; i < models.length; i++) {\n\t\t\tconst url = `/api/datascience/ml/v1/models/${models[i]}/ownership`;\n\t\t\tconst data = { userId: newOwnerId };\n\t\t\tawait handleRequest('POST', url, data);\n\t\t}\n\t\tawait logTransfers(userId, newOwnerId, 'AI_MODEL', models); // Not recorded in the activity log\n\t}\n}\n\n//-----------------------------------AI Projects----------------------------------//\n\nasync function transferAiProjects(userId, newOwnerId, filteredIds = []) {\n\tlet projects = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tprojects = filteredIds;\n\t} else {\n\t\t// Use existing discovery logic\n\t\tconst limit = 50;\n\t\tlet offset = 0;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tlimit: 50,\n\t\t\t\toffset: 0,\n\t\t\t\tsortFieldMap: {\n\t\t\t\t\tCREATED: 'DESC'\n\t\t\t\t},\n\t\t\t\tsearchFieldMap: { NAME: '' },\n\t\t\t\tfilters: [{ type: 'OWNER', values: [userId] }],\n\t\t\t\tmetricFilters: {},\n\t\t\t\tdateFilters: {},\n\t\t\t\tsortMetricMap: {}\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/datascience/ml/v1/search/projects',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response && response.projects.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tconst ids = response.projects.map((model) => model.id);\n\t\t\t\tprojects.push(...ids);\n\n\t\t\t\tif (response.projects.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\n\t\t\t\toffset += limit;\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (projects.length > 0) {\n\t\tfor (let i = 0; i < projects.length; i++) {\n\t\t\tconst url = `/api/datascience/ml/v1/projects/${projects[i]}/ownership`;\n\t\t\tconst data = { userId: newOwnerId };\n\t\t\tawait handleRequest('POST', url, data);\n\t\t}\n\t\tawait logTransfers(userId, newOwnerId, 'AI_PROJECT', projects); // Not recorded in the activity log\n\t}\n}\n\n//--------------------------ProjectsAndTasks--------------------------//\n\nasync function transferProjectsAndTasks(userId, newOwnerId, filteredIds = []) {\n\tlet allIds = [];\n\tlet projects = [];\n\tlet tasks = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list - combine PROJECT and PROJECT_TASK types\n\t\tallIds = filteredIds;\n\t\t// We'll need to fetch project details for each ID to process them properly\n\t\tfor (const id of filteredIds) {\n\t\t\ttry {\n\t\t\t\t// Try to get as project first\n\t\t\t\tconst project = await handleRequest(\n\t\t\t\t\t'GET',\n\t\t\t\t\t`/api/content/v1/projects/${id}`\n\t\t\t\t);\n\t\t\t\tif (project && project.assignedTo == userId) {\n\t\t\t\t\tprojects.push(project);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// If not a project, might be a task\n\t\t\t\ttry {\n\t\t\t\t\tconst task = await handleRequest(\n\t\t\t\t\t\t'GET',\n\t\t\t\t\t\t`/api/content/v1/tasks/${id}`\n\t\t\t\t\t);\n\t\t\t\t\tif (task) {\n\t\t\t\t\t\ttasks.push(task);\n\t\t\t\t\t}\n\t\t\t\t} catch (taskError) {\n\t\t\t\t\tconsole.error(`Failed to process ID ${id}:`, taskError);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet offset = 0;\n\t\tconst limit = 100;\n\t\tlet moreData = true;\n\n\t\twhile (moreData) {\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'GET',\n\t\t\t\t`/api/content/v2/users/${userId}/projects?limit=${limit}&offset=${offset}`\n\t\t\t);\n\n\t\t\tif (response && response.length > 0) {\n\t\t\t\t// Extract ids and append to list\n\t\t\t\tprojects.push(...response.projects);\n\n\t\t\t\t// Increment offset to get next page\n\t\t\t\toffset += limit;\n\n\t\t\t\t// If less than pageSize returned, this is the last page\n\t\t\t\tif (response.length < limit) {\n\t\t\t\t\tmoreData = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No more data returned, stop loop\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\n\t\t// Get tasks for each project\n\t\tfor (let i = 0; i < projects.length; i++) {\n\t\t\tconst taskResponse = await handleRequest(\n\t\t\t\t'GET',\n\t\t\t\t`/api/content/v1/projects/${projects[i].id}/tasks?assignedToOwnerId=${userId}`\n\t\t\t);\n\n\t\t\tif (taskResponse && taskResponse.length > 0) {\n\t\t\t\ttasks.push(...taskResponse);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Process tasks\n\tlet taskIds = [];\n\tfor (const task of tasks) {\n\t\ttaskIds.push(task.id);\n\t\tif (task.primaryTaskOwner == userId) {\n\t\t\ttask.primaryTaskOwner = newOwnerId;\n\t\t}\n\t\ttask.contributors.push({\n\t\t\tassignedTo: newOwnerId,\n\t\t\tassignedBy: userId\n\t\t});\n\t\ttask.owners.push({\n\t\t\tassignedTo: newOwnerId,\n\t\t\tassignedBy: userId\n\t\t});\n\t\tawait handleRequest('PUT', `/api/content/v1/tasks/${task.id}`, task);\n\t}\n\n\t// Process projects\n\tlet projectIds = [];\n\tfor (const project of projects) {\n\t\tif (project.assignedTo == userId) {\n\t\t\tprojectIds.push(project.id);\n\t\t\tconst url = `/api/content/v1/projects/${project.id}`;\n\t\t\tconst body = { id: project.id, creator: newOwnerId };\n\t\t\tawait handleRequest('PUT', url, body);\n\t\t}\n\t}\n\n\tif (taskIds.length > 0) {\n\t\tawait logTransfers(userId, newOwnerId, 'PROJECT_TASK', taskIds);\n\t}\n\tif (projectIds.length > 0) {\n\t\tawait logTransfers(userId, newOwnerId, 'PROJECT', projectIds);\n\t}\n}\n\nasync function transferMetrics(userId, newOwnerId, filteredIds = []) {\n\tlet metrics = [];\n\n\tif (filteredIds.length > 0) {\n\t\t// Use the provided filtered list\n\t\tfor (const metricId of filteredIds) {\n\t\t\ttry {\n\t\t\t\tawait handleRequest(\n\t\t\t\t\t'POST',\n\t\t\t\t\t`/api/content/v1/metrics/${metricId}/owner/${newOwnerId}`\n\t\t\t\t);\n\t\t\t\tmetrics.push(metricId);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Failed to transfer metric ${metricId}:`, error);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Use existing discovery logic\n\t\tlet moreData = true;\n\t\tlet offset = 0;\n\t\tconst limit = 100;\n\n\t\twhile (moreData) {\n\t\t\tconst data = {\n\t\t\t\tnameContains: 'string',\n\t\t\t\tfilters: {\n\t\t\t\t\tOWNER: [userId]\n\t\t\t\t},\n\t\t\t\torderBy: 'CREATED',\n\t\t\t\tfollowed: false,\n\t\t\t\tdescendingOrderBy: false,\n\t\t\t\tlimit: limit,\n\t\t\t\toffset: offset\n\t\t\t};\n\n\t\t\tconst response = await handleRequest(\n\t\t\t\t'POST',\n\t\t\t\t'/api/content/v1/metrics/filter',\n\t\t\t\tdata\n\t\t\t);\n\n\t\t\tif (response && response.metrics.length > 0) {\n\t\t\t\t// Process metrics\n\t\t\t\tfor (const metric of response.metrics) {\n\t\t\t\t\tawait handleRequest(\n\t\t\t\t\t\t'POST',\n\t\t\t\t\t\t`/api/content/v1/metrics/${metric.id}/owner/${newOwnerId}`\n\t\t\t\t\t);\n\t\t\t\t\tmetrics.push(metric.id);\n\t\t\t\t}\n\n\t\t\t\toffset += limit;\n\t\t\t} else {\n\t\t\t\tmoreData = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (metrics.length > 0) {\n\t\tawait logTransfers(userId, newOwnerId, 'METRIC', metrics);\n\t}\n}\n\n\nmodule.exports = {getUserName,deleteUserSessions,deleteUsersSessions,deleteSession,deleteUser,appendToDataset,logTransfers,transferContent,transferDatasets,transferDataflows,transferCards,transferAlerts,transferWorkflows,transferTaskCenterQueues,transferTaskCenterTasks,transferAppStudioApps,transferPages,transferScheduledReports,getCurrentPeriod,transferGoals,transferGroups,transferAppDbCollections,transferFunctions,transferAccounts,transferJupyterWorkspaces,transferCodeEnginePackages,transferFilesets,getPublications,transferSubscriptions,transferRepositories,transferApprovals,transferApprovalTemplates,transferCustomApps,transferAiModels,transferAiProjects,transferProjectsAndTasks,transferMetrics};",
  "createdBy": "1813188617",
  "updatedOn": "2025-11-26T16:50:11.735Z",
  "releasedOn": "2025-11-26T16:50:11.735Z",
  "functions": [
    {
      "name": "appendToDataset",
      "displayName": "Append To Dataset",
      "description": "",
      "example": "### Input \n\n - **csvValues**: \n - **datasetId**: 2df07ed5-03ca-44be-b47b-fe936c431337\n\n --- \n\n### Output \n\n - **response**: \n  ``` \n{}\n```",
      "isPrivate": false,
      "inputs": [
        {
          "name": "csvValues",
          "displayName": "csvValues",
          "type": "text",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "datasetId",
          "displayName": "datasetId",
          "type": "text",
          "value": "2df07ed5-03ca-44be-b47b-fe936c431337",
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ],
      "output": {
        "name": "response",
        "displayName": "response",
        "type": "object",
        "value": null,
        "nullable": true,
        "isList": false,
        "children": [],
        "entitySubType": null
      }
    },
    {
      "name": "deleteSession",
      "displayName": "Delete Session",
      "description": "",
      "example": "### Input \n\n - **sessionId**: ",
      "isPrivate": false,
      "inputs": [
        {
          "name": "sessionId",
          "displayName": "sessionId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "deleteUser",
      "displayName": "Delete User",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "deleteUserSessions",
      "displayName": "Delete User Sessions",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "deleteUsersSessions",
      "displayName": "Delete Users Sessions",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userIds",
          "displayName": "userIds",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "getCurrentPeriod",
      "displayName": "Get Current Period",
      "description": "",
      "isPrivate": false,
      "inputs": [],
      "output": {
        "name": "currentPeriodId",
        "displayName": "currentPeriodId",
        "type": "number",
        "value": null,
        "nullable": true,
        "isList": false,
        "children": [],
        "entitySubType": null
      }
    },
    {
      "name": "getPublications",
      "displayName": "Get Publications",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ],
      "output": {
        "name": "publications",
        "displayName": "publications",
        "type": "object",
        "value": null,
        "nullable": true,
        "isList": true,
        "children": [],
        "entitySubType": null
      }
    },
    {
      "name": "getUserName",
      "displayName": "Get User Name",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ],
      "output": {
        "name": "userName",
        "displayName": "userName",
        "type": "text",
        "value": null,
        "nullable": true,
        "isList": false,
        "children": [],
        "entitySubType": null
      }
    },
    {
      "name": "logTransfers",
      "displayName": "Log Transfers",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "type",
          "displayName": "type",
          "type": "text",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "ids",
          "displayName": "ids",
          "type": "text",
          "value": null,
          "nullable": false,
          "isList": true,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "status",
          "displayName": "status",
          "type": "text",
          "value": "TRANSFERRED",
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "notes",
          "displayName": "notes",
          "type": "text",
          "value": null,
          "nullable": true,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "resourceExists",
      "displayName": "Resource Exists",
      "description": "",
      "isPrivate": true,
      "inputs": [
        {
          "name": "type",
          "displayName": "type",
          "type": "text",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "id",
          "displayName": "id",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ],
      "output": {
        "name": "result",
        "displayName": "result",
        "type": "boolean",
        "value": null,
        "nullable": true,
        "isList": false,
        "children": [],
        "entitySubType": null
      }
    },
    {
      "name": "sanitizeLinks",
      "displayName": "Sanitize Links",
      "description": "",
      "isPrivate": true,
      "inputs": [
        {
          "name": "links",
          "displayName": "links",
          "type": "object",
          "value": null,
          "nullable": false,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ],
      "output": {
        "name": "cleanedLinks",
        "displayName": "cleanedLinks",
        "type": "object",
        "value": null,
        "nullable": true,
        "isList": true,
        "children": [],
        "entitySubType": null
      }
    },
    {
      "name": "transferAccounts",
      "displayName": "Transfer Accounts",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferAiModels",
      "displayName": "Transfer Ai Models",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferAiProjects",
      "displayName": "Transfer Ai Projects",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferAlerts",
      "displayName": "Transfer Alerts",
      "description": "",
      "example": "### Input \n\n - **alerts**: \n  ``` \nnull\n```\n - **newOwnerId**: \n - **userId**: ",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferAppDbCollections",
      "displayName": "Transfer App Db Collections",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferAppStudioApps",
      "displayName": "Transfer App Studio Apps",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferApprovalTemplates",
      "displayName": "Transfer Approval Templates",
      "description": "",
      "example": "### Input \n\n - **userId**: \n - **newOwnerId**: ",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferApprovals",
      "displayName": "Transfer Approvals",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferCards",
      "displayName": "Transfer Cards",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferCodeEnginePackages",
      "displayName": "Transfer Code Engine Packages",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferContent",
      "displayName": "Transfer Content",
      "description": "",
      "example": "### Input \n\n - **userId**: \n - **newOwnerId**: \n - **objectsToTransfer**: \n  ``` \n[]\n```",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "objectsToTransfer",
          "displayName": "objectsToTransfer",
          "type": "object",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [
            {
              "name": "id",
              "displayName": "id",
              "type": "text",
              "value": null,
              "nullable": false,
              "isList": false,
              "children": null,
              "entitySubType": null
            },
            {
              "name": "type",
              "displayName": "type",
              "type": "text",
              "value": null,
              "nullable": false,
              "isList": false,
              "children": null,
              "entitySubType": null
            }
          ],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferCustomApps",
      "displayName": "Transfer Custom Apps",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferDataflows",
      "displayName": "Transfer Dataflows",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferDatasets",
      "displayName": "Transfer Datasets",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ],
      "output": {
        "name": "response",
        "displayName": "response",
        "type": "object",
        "value": null,
        "nullable": true,
        "isList": false,
        "children": [],
        "entitySubType": null
      }
    },
    {
      "name": "transferFilesets",
      "displayName": "Transfer Filesets",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferFunctions",
      "displayName": "Transfer Functions",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferGoals",
      "displayName": "Transfer Goals",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "periodId",
          "displayName": "periodId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferGroups",
      "displayName": "Transfer Groups",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferJupyterWorkspaces",
      "displayName": "Transfer Jupyter Workspaces",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferMetrics",
      "displayName": "Transfer Metrics",
      "description": "",
      "example": "### Input \n\n - **userId**: \n - **newOwnerId**: \n - **filteredIds**: \n  ``` \n[]\n```",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferPages",
      "displayName": "Transfer Pages",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferProjectsAndTasks",
      "displayName": "Transfer Projects And Tasks",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferRepositories",
      "displayName": "Transfer Repositories",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferScheduledReports",
      "displayName": "Transfer Scheduled Reports",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferSubscriptions",
      "displayName": "Transfer Subscriptions",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferTaskCenterQueues",
      "displayName": "Transfer Task Center Queues",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferTaskCenterTasks",
      "displayName": "Transfer Task Center Tasks",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    },
    {
      "name": "transferWorkflows",
      "displayName": "Transfer Workflows",
      "description": "",
      "isPrivate": false,
      "inputs": [
        {
          "name": "userId",
          "displayName": "userId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "newOwnerId",
          "displayName": "newOwnerId",
          "type": "number",
          "value": null,
          "nullable": false,
          "isList": false,
          "children": [],
          "entitySubType": null
        },
        {
          "name": "filteredIds",
          "displayName": "filteredIds",
          "type": "text",
          "value": [],
          "nullable": true,
          "isList": true,
          "children": [],
          "entitySubType": null
        }
      ]
    }
  ],
  "configuration": {
    "accountsMapping": [],
    "mlModel": [],
    "externalPackageMapping": {}
  },
  "createdOn": "2025-11-17T19:00:36.414Z",
  "updatedBy": "1813188617"
}